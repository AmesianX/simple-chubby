\section{Introduction}

\subsection{Terminology}

\begin{itemize}[noitemsep]
  \item Users.
  Programmers who use SimpleChubby user-level interfaces to write a user-defined synchronization service.
  \item Servers.
  SimpleChubby service runs on a set of processes called servers.
  \item Clients.
  A user-written program runs on a process called a client, which connects to the server
  and cooperates with the server to implement SimpleChubby lock service.
  \item Leader server.
  One of servers is responsible for processing requests from the clients, and coordinates other servers.
  \item Follower server.
  The servers other than the leader servers.
\end{itemize}

\subsection{System architecture}

SimpleChubby implementation consists of a client library linked to user programs,
and a server executable running on each server.

\subsubsection{Client side}
The client library offers a set of interfaces for users to access SimpleChubby lock service,
and talks with the leader server to implement the interfaces. 

User code does not talk with the leader server directly since the client library
needs to know what requests are issued so that it can help a leader server
to recover lost states during a server fail-over.
Meanwhile, the client library can do certain sanity checks before sending requests
to the leader server.

The client library also cooperates with the servers to achieve server fail-over.  
It tries to connect to a new leader server once the old one fails,
and help the new server recover such lost states
as open files, registered events, and lock waiting queues
using client side information.

\subsubsection{Server side}

SimpleChubby runs a group of servers to provide a reliable lock service.

A server can run as the leader server or as a follower server,
as decided by a consensus protocol.
When running as a follower server, it serves as a replica to duplicate critical
operations happening on the leader server, and prepares to be promoted to a leader server.
When running as a leader server, it accepts and processes requests from clients.
The leader server also monitors client failures, and clears its states after failure,
i.e., reclaiming its holding locks after a certain timeout.

The leader server maintains two categories of states.
The first category of states includes lock ownership and file system content. These
states are made persistent, and accesses or changes to them go through a consensus protocol.
The second category of states includes active client lists,
open files, registered events, and lock waiting queues.
Theses states can be recovered with the help of clients,
and thus are not persistent and does not go through a consensus protocol.

SimpleChubby does not make all the leader server states persistent by a consensus protocol,
because it takes too much overhead to maintain all the states,
but certain states can be easily recovered
using client side information, for example, lock waiting queues.
File content and lock ownership cannot be reliably recovered by client
side information, and thus has to be made persistent by a consensus protocol.
For example, when a client loses connection with the leader server,
and reconnects later,
it might assume owning a lock, which other clients might not agree on.
In this case, the client side information is not enough for recovering
the lock ownership reliably.
 
\subsection{Details about the client}
To be simple, and avoid overwhelming the server, the client process will block until a remote procedure call is
replied unless the leader server fails. That is, only one outstanding remote procedure call is allowed between
a client and the leader server.

\subsection{Details about the server}
When user code invokes the interfaces to access files or perform locking operations,
the client library performs corresponding remote procedure calls to the leader server,
waits for replies from the leader server, and returns the result back to the user.
A user can also register certain events,
such as a file modification event or a lock ownership change event, 
in the client library,
and it will be notified when the registered events happen.
Event notification happens asynchronized with other user interface calls.

\subsection{TODO}
Server part needs a good starting paragraph.

The file hanlder is important.

Application: group membership, at least one experiment.

What is implemented and what is not.

\subsection{Service Sematics}

Draft.

The sematics of locks, and the behavoir after fail-over.

Access to files are serialized with/without fail-over.

Once a file is open, always read the same version. Other deletion will
reflect immediately, because of file handlers, and instance number.

a lock is given to only one client. Once a client fails, the lock
is reclaimed after a timeout. Once the leader fails, the lock remains
in the client, but will be reclaimed if the client fails to connect
to the new leader after a certain timeout.

lock might be given to two clients, sequencer as mentioned in Chubby.

Events are delivered asynchronized, different from Zookeeper. After
server fail-over, once the client reconnects, no events will be missed.

