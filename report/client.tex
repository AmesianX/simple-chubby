The client library of SimpleChubby is mainly responsible for sending RPCs to the
server, and returning the results to the user-level applications.
To avoid overwhelming the server, the client process will block until a RPC
gets replied, unless the leader server fails. This implies that only one
outstanding RPC is allowed between a client and the leader server.

In addition, to support event handling, the client library also needs to
monitor the event message delivered from the server and execute up-call
to the user level. Some API functions, such as \texttt{acquire()}, can put
the main thread into sleep. Also, event handling callback usually needs to
be synchronized with the main thread. We guarantee that the user application
and the event handling will not block each other. Also, a dedicated polling
thread is used to poll the messages received from the server and deliver to
user application or event handling thread depending on whether the message
is a RPC reply or an event. These features are necessary
for the applications we implemented in Section~\ref{section:apps}.

Finally, when the leader server fails, the client library needs to figure out
the new leader after server-side view change, and helps to recover some
non-persistent state at the server side. We will talk about the details in
Section~\ref{section:failure}



%The leader only replicates and persistently keeps part of its state for
%simplicity, as described in Section~\ref{TODO}. When failure happens, some
%states, including the lock waiting queues and the event subscribing lists,
%will be lost and can't be automatically recovered at the new leader. Therefore,
%the client library needs to keep this information locally. When it connects
%to the new leader server, it needs to re-send the \texttt{acquire()} RPC,
%and tells the new leader all the events it subscribes.

