The client library of SimpleChubby is responsible for sending RPCs to the
leader server, and returning the results to the user-level applications.
To avoid overwhelming the server, the client process will block until a RPC
gets replied. This implies that only one
outstanding RPC is allowed between a client and the leader server.

In addition, the client library needs to
monitor the event message from the server and execute up-call
to the user level. Some API functions, such as \texttt{acquire()}, can put
the application into sleep. Moreover, user applications sometimes explicitly
wait for specific events to happen. Therefore we guarantee the events delivered to the
clients will be handled in time regardless of the progress of the user application
Also, a dedicated polling
thread is used to poll the messages received from the server and deliver to
user application or event handling thread depending on whether the message
is a RPC reply or an event. These features are necessary
for the applications we implemented in Section~\ref{section:apps}.

Finally, when the leader server fails, the client library needs to figure out
the new leader after server-side view change, and helps to recover some
non-persistent states at the server side. We will talk about the details in
Section~\ref{section:failure}



%The leader only replicates and persistently keeps part of its state for
%simplicity, as described in Section~\ref{TODO}. When failure happens, some
%states, including the lock waiting queues and the event subscribing lists,
%will be lost and can't be automatically recovered at the new leader. Therefore,
%the client library needs to keep this information locally. When it connects
%to the new leader server, it needs to re-send the \texttt{acquire()} RPC,
%and tells the new leader all the events it subscribes.

