\section{Fault Tolerance}
\label{section:failure}

\subsection{Client Failure}

During a client failure, the leader server releases all the locks
previously held by the failed client after a certain timeout.
This guarantees that locks are eventually released and no deadlock happens.

For garbage collection
purpose, the server also deletes all the file handlers opened by the client,
outstanding lock acquire requests sent by the client, and all the registered
events from the client.

Each client maintains a TCP connection with the leader server,
which is called a session.
The session is dead if either end shuts down the TCP connection.
And the leader server will assume a client failure once the session is dead.
Notice that this is a simplified implementation.
If a client dies before explicitly shutting down the TCP connection,
the client failure cannot be detected.

\subsection{Server Failover}

When the leader server fails, the Viewchange protocol elects a new leader. After
the leader change, all persistent data remain consistent. However, the in-memory
data structures at the new leader need to be reconstructed. The new leader
does this partially by scanning the persistent data. 
Two methods are used for the reconstruction.
First, a client sends reopen requests after it connects to the new leader.
To precisely reconstruct the queues of outstanding lock acquire requests and
the queues of registered event from clients, the client library should keep
a copy of these requests locally and send a set of reopen requests and
potentially a lock acquire request to the new leader after it reconnects
to the new leader after a leader change.

Secondly, it is not necessary to reconstruct the information of all the file
handlers held by clients eagerly. Instead, we reconstruct the file handler
information in the normal case of the SimpleChubby processing after the
leader change. If the new leader receives a request with a file handler that
missing in the leader's memory, it checks the signiture of the file
handler and initiates a reopen. If the reopen succeeds (i.e. the node exits
and the meta data matches), the leader add this file handler into its memory.
